import * as scanner from "@nodesecure/scanner";
import type { Scanner } from "@nodesecure/scanner";
import * as vuln from "@nodesecure/vuln";

import * as RC from "../config/nodesecurerc.js";
import { runPayloadInterpreter } from "../payload/interpret.js";
import { reportScannerLoggerEvents, runReporter } from "../reporters/index.js";
import { ValueOf } from "../types/index.js";

import * as pipeline from "./run.js";

export const status = {
  SUCCESS: "success",
  FAILURE: "failure"
} as const;

export type Status = ValueOf<typeof status>;

export function getOutcome(result: boolean): Status {
  return result ? status.SUCCESS : status.FAILURE;
}

async function runScannerAnalysis(
  runtimeConfig: RC.Configuration
): Promise<Scanner.Payload> {
  const { strategy } = await vuln.setStrategy(
    vuln.strategies[runtimeConfig.strategy]
  );
  const logger = new scanner.Logger();

  reportScannerLoggerEvents(logger);

  const payload = await scanner.cwd(
    runtimeConfig.rootDir,
    {
      vulnerabilityStrategy: strategy
    },
    logger
  );

  return payload;
}

function fail() {
  process.exit(1);
}

async function runPayloadChecks(
  payload: Scanner.Payload,
  rc: RC.Configuration
) {
  const interpretedPayload = runPayloadInterpreter(payload, rc);
  await runReporter(interpretedPayload, rc);

  if (interpretedPayload.status === pipeline.status.FAILURE) {
    fail();
  }
}

export async function runPipeline(options: {
  warnings: RC.Warnings;
  vulnerability: RC.Severity;
}): Promise<void> {
  const { warnings, vulnerability } = options;
  /**
   * For now, the runtime configuration comes from a in-memory constant.
   * In the future, this configuration will come from a .nodesecurerc parsed
   * at runtime.
   */
  try {
    const runtimeConfig: RC.Configuration = {
      ...RC.DEFAULT_RUNTIME_CONFIGURATION,
      vulnerabilities: {
        severity: vulnerability
      },
      warnings
    };
    const analysisPayload = await runScannerAnalysis(runtimeConfig);
    /**
     * Once the payload generated by the scanner analysis is available, we can
     * now run the interpreter and use the config to determine whether the
     * pipeline should fail or be successful.
     */
    await runPayloadChecks(analysisPayload, runtimeConfig);
  } catch {
    fail();
  }
}
